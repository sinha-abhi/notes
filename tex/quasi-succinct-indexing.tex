% Notes on Quasi-Succinct Indexing
%   Adapted from `Quasi-Succinct Indices` by Sebastiano Vigna at 
%   https://arxiv.org/abs/1206.4300
% 
% Abhinav Sinha, sinha45@purdue.edu
% 2019-12-12
\documentclass[10pt]{article}

%\input{/home/abhi/abhi/personal/git-repos/config/preamble.tex}
\input{/Users/abhisinha/git/configuration/preamble.tex}

\title{Notes}
\subject{Quasi-Succinct Indexing}
\date{December 12, 2019}

\hypersetup{unicode = true,
            pdftitle = {quasi-succinct-indexing},
            pdfborder = {0 0 0},
            breaklinks = true}

\begin{document}
\maketitle

\section{Quasi-Succinct Indexing}\label{quasi-succinct-indexing}
\subsection{Index Compression}\label{index-compression}
\begin{itemize}
\item
    Instantaneous codes -- storage of integers is proportional to size of integer
    \begin{itemize}    
    \item
        smaller numbers use fewer bits
    \end{itemize}
\item
    Gap encoding -- turns lists of increasing numbers into lists of smaller integers
    \begin{itemize}
    \item
        smaller integers being the gaps between successive values
    \end{itemize}
\end{itemize}

\subsection{Brief Overview of Unary-Code}\label{unary-code}
Unary code represents a natural number \(n\) as
\begin{itemize}
\item
    \(n\) 1's followed by a 0 -- for \(n\) \textit{non-negative}, or
\item
    \(n - 1\) 1's followed by a 0 -- for \(n\) \textit{strictly positive}.
\end{itemize}
We can exchanges 0's and 1's without loss of generality.
The flipped version is often called negated unary code.
\underline{Example}: 
\( 5 \rightarrow \texttt{111110} \text{ or } \texttt{000001} \)

\subsection{Representation of a Monotone Sequence}\label{monotone-sequence}
Suppose we have the following monotone sequence for \(x_i \in \NN\):
\[ x_0 \leq x_1 \leq \ldots \leq x_{n-1} \leq u, \]
where \(u\) is some upper bound.

\begin{itemize}
\item
    We store the sequence in a ``high/low bit representation'' using two \textit{bit-arrays}.
    \begin{itemize}
    \item
        The lower \(l = \max{\lbrace 0, \left \lfloor\log{\frac{u}{n}} \right \rfloor \rbrace }\) 
        bits of each \(x_i\) are stored \textit{explicitly} and \textit{contiguously} in a 
        \textbf{lower-bits array}.
    \item
        The remaining upper bits are stored as a sequence of \textit{unary code gaps} in an
        \textbf{upper-bits array}.
        \begin{itemize}
        \item
            difference in upper bits 
            \(= \left \lfloor \frac{x_i}{2^l} \right \rfloor 
              - \left \lfloor \frac{x_{i-1}}{2^l} \right \rfloor\).
        \item
            For the sake of completeness, let \(x_{-1} = 0\).
        \end{itemize}
    \end{itemize}
\item
    This representation uses at most \(2 + \left \lceil \log{\frac{u}{n}} \right \rceil\) bits
    \textbf{per element} meaning that this representation is \textbf{quasi-succinct}.
    \begin{proof}
    Each unary encoding uses 1 stop bit, and each other written bit increases the value 
    of the upper bits by \(2^l\). 
    This cannot happen more than
    \( \left \lfloor \frac{x_{n-1}}{2^l} \right \rfloor \) times.
    This leads us to the following:
    \[ \left \lfloor \frac{x_{n-1}}{2^l} \right \rfloor 
       \leq \left \lfloor \frac{u}{2^l} \right \rfloor
       \leq \frac{u}{2^l} \leq 2n. \]
    Unless \(\frac{u}{n}\) is a power of 2, we have 
    \[ \left \lceil \log{\frac{u}{n}} \right \rceil 
       = \left \lfloor \log{\frac{u}{n}} \right \rfloor + 1. \]
    If \(\frac{u}{n}\) is a power of 2, then 
    \[ \left \lceil \log{\frac{u}{n}} \right \rceil = \log{\frac{u}{n}}, \]
    but the previous equation is bounded by \(n\) instead of \(2n\).
    The informational-theorectial limit is
    \[ \left \lceil \log{\binom{u + n}{n}} \right \rceil 
       \approx n \log{\left( \frac{u + n}{n} \right) }, \]
    so we conclude that this representation is close to succinct.
    \end{proof}
\end{itemize}

\subsection{Example}\label{example}
Suppose we have a list \texttt{[5, 8, 8, 15, 32]} with \(u= 36\).
We compute \(l = \left \lfloor \log{\frac{36}{5}} \right \rfloor = 2 \).
Split the lower \(l\) bits of the binary representation of each element of the list.
\begin{verbatim}
    5           8           8          15            32
+---+----+ +----+----+ +----+----+ +----+----+ +------+----+
| 1 | 01 | | 10 | 00 | | 10 | 00 | | 11 | 11 | | 1000 | 00 |
+---+----+ +----+----+ +----+----+ +----+----+ +------+----+
\end{verbatim}
The lower bits array:
\begin{verbatim}
+----+----+----+----+----+----+
| 01 | 00 | 00 | 11 | 00 | 00 |
+----+----+----+----+----+----+
\end{verbatim}
To compute the upper bits array, we find the difference between each of the upper bits
and then convert to unary code.
\begin{verbatim}
    5           8           8          15            32
+---+----+ +----+----+ +----+----+ +----+----+ +------+----+
| 1 | 01 | | 10 | 00 | | 10 | 00 | | 11 | 11 | | 1000 | 00 |
+---+----+ +----+----+ +----+----+ +----+----+ +------+----+
  |          |           |           |            |
  |          |           |           |            |
  v          v           v           v            v
  1          2           2           3            8
\end{verbatim}
Recall that we choose \(x_{-1} = 0\) for simplicity.
The upper bits array:
\begin{verbatim}
  1     1   0   1      5
+----+----+---+----+--------+
| 01 | 01 | 1 | 01 | 000001 |
+----+----+---+----+--------+
\end{verbatim}

\subsection{Recovering \texorpdfstring{\(x_i\)}{xi}}\label{recovering-xi}
\begin{itemize}
\item
    Perform \(i\) unary code reads in the upper-bits array to position \(p\) bits
    \begin{itemize}
    \item
        The value of the upper bits is exactly \(p - i\)
    \item
        \underline{Example}: To read the upper bits of 15, we perform 4 unary code reads to 
        position 7 of the upper bits array.
        Thus, the value of the upper bits of 15 is \(7 - 4 = 3\).
    \end{itemize}
\item
    Extract lower bits with random access at position \(il\) in the lower bits array
\end{itemize}

\subsection{Some Optimizations for Accessing}\label{optimizations}

\subsubsection{Forward Pointers}\label{forward-pointers}
\begin{itemize}
\item
    Choose a \textit{quantum} \(q\)
\item
    Store \textbf{forward pointers} at positions that one would reach after 
    \(kq\) unary code reads
    \begin{itemize}
    \item
        This is the position immediately after \(kq - 1\) bits
    \end{itemize}
\item
    Retrieve \(x_i\) by simulatinging \(q \left \lfloor \frac{i}{q} \right \rfloor\) reads
    then \(i \mod q\) sequential reads
\end{itemize}
\subsubsection{Skip Pointers}\label{skip-pointers}
\begin{itemize}
\item
    -- TODO --
\end{itemize}

\subsection{Quasi-Succinct Bitstream}\label{quasi-succinct-bitstream}
-- TODO --

\end{document}